{"componentChunkName":"component---src-templates-blog-post-js","path":"/plan/","webpackCompilationHash":"3f140a86e57aedcffce9","result":{"data":{"site":{"siteMetadata":{"title":"Bruno Opsenica's Blog","author":"Bruno Opsenica"}},"markdownRemark":{"id":"f8e61a9b-82fb-5d4c-8514-14122ada50cc","excerpt":"Path Forward My ultimate goal is to start working in the games industry as a graphics programmer In order to achieve this goal, I want to demonstrate that I…","html":"<h1>Path Forward</h1>\n<ul>\n<li>My ultimate goal is to start working in the games industry as a graphics programmer</li>\n<li>In order to achieve this goal, I want to demonstrate that I have an understanding of the field both from a conceptual and practical point of view.</li>\n<li>\n<p>To that end, I identified the following as ways to demonstrate my understanding:</p>\n<ul>\n<li>Implementing various graphics techniques in my spare time</li>\n<li>Writing blog posts about some of those implementations</li>\n</ul>\n</li>\n</ul>\n<p>However, the first item is obviously not well defined, especially once you consider that computer graphics is an entire academic field. Additionally, implementing anything requires us to make a lot of choices. What techniques are most relevant to modern video games? What technical choices should I be making to maximize relevance to actual industry practice, while also maximizing my velocity of learning.</p>\n<p>Some of the key technical questions I want to answer are:</p>\n<ul>\n<li>\n<p>Should I continue to focus on implementing techniques using an abstraction layer like BGFX <em>or</em> should I start focusing on using writing my own wrapper for a modern low level API like D3D12/Vulkan.</p>\n<ul>\n<li>Using an existing library or higher level API allows me to focus on implementing computer graphics techniques, instead of focusing on issues like low level memory allocation, residency, and resource barriers.</li>\n<li>Newer APIs like D3D12 allow for implementation of techniques like multi-threaded command buffer submission and real-time ray tracing.</li>\n</ul>\n</li>\n<li>\n<p>Should I continue to implement different techniques as standalone examples <em>or</em> work on a combined example.</p>\n<ul>\n<li>On the one hand, standalone examples can increase velocity as code needs satisfy a smaller set of requirements with no backwards compatibility</li>\n<li>On the other hand, standalone examples increase start up cost of creating a new example.</li>\n<li>Additionally, a larger combined example would force me to work in a larger C++ codebase, something I could use more experience with, as well as forcing me to deal with the greater complexity involved in having many passes with dependencies between them.</li>\n</ul>\n</li>\n</ul>\n<h2>Vulkan/DX12?</h2>\n<p>To gain some insight into this, I did a quick and dirty survey of graphics programmer job postings, taking the qualifications listed and seeing if I could crudely sort them to gain a sense of what work and research I should prioritize. My pool of postings was small, involving around 12 postings of different seniority levels ranging from Junior to Senior. For the most part there were not many surprises: nearly every posting required experience in graphics programming and having shipped at least one title, and there wasn’t a single posting that listed a language other than C/C++. Similarly, knowledge of the modern graphics pipeline and writing shaders for the different stages was included in most applications. Required education was always listed as “Bachelor’s degree in Computer Science or equivalent”, also unsurprising.</p>\n<p>More interestingly, there was only a slight preference given to DirectX over its contemporaries, and specifically DX11 at that. Knowledge of the newer, lower level APIs (D3D12 and Vulkan) was only listed as a required in one application, less frequently than DX11. This is perhaps unsurprising for people with <a href=\"https://twitter.com/tom_forsyth/status/1191952259967586306\">experience of both types of graphics APIs</a>, as Vulkan and D3D12 are not necessarily meant as replacements.</p>\n<p>So a demo using my own Vulkan/D3D12 may not actually be particularly helpful.</p>\n<h2>BGFX vs Custom Lib</h2>\n<h3>What Do I Actually Want?</h3>\n<p>I’d like to be able to iterate quicker that currently possible with my separate examples. One of the problems right now is inertia - changing shared code produces problems with existing examples. This problem could be addressed by having no shared code, but then we encounter a different problem, which is that each example needs a LOT of code duplication, and that I’m never building up anything other than the most foundational pieces over and over again.</p>\n<p>I’d like to also be able to eventually settle on a stable method for managing meshes and materials. I don’t know if this is possible however, given that my ability to abstract this will always be more flawed.</p>\n<p>I’d like to organize my code better. Right now with these examples almost everything has been dumped directly into the <code class=\"language-text\">update</code> method, but this won’t scale as we add more and more passes. However, I haven’t developed any model for passing around the required data to different ‘modules’ that might define the different phases of my renderer.</p>\n<p>I’d like to be able to perform meaningful performance testing and optimization. Right now I don’t even know how I’d start doing that.</p>\n<h3>Problems I’ve had in the past</h3>\n<p>With the D3D12 work I’ve been doing, I’ve had the issue that too much of it is already there, so I don’t want to just start from that point. But writing it all myself is overwhelming, and I keep wondering whether I should be making changes to that work or not. It’s extremely OOP, which I’m not sure is a good thing, but at the same time I don’t have enough experience to start making all those changes myself. It’s also hard to predict what needs to be abstracted and what doesn’t.</p>\n<p>The other issue I’ve had is that I haven’t had performance issues with any of my examples, except forward rendering. So it’s hard to understand what I need to optimize. Similarly, it’s not clear what I need to benchmark in the first place!</p>\n<h3>How to Address That</h3>\n<ul>\n<li>Stop prematurely abstracting.</li>\n<li>Stop writing separate examples. Let’s focus on a single infrastructure, and we can figure out how to best support separate scenes later. It’d be great if we could have it be data driven! :wink:</li>\n<li>Let’s keep making progress incrementally! Things don’t have to be perfect all at once!!</li>\n<li>Stop starting over! If I use Vulkan/D3D12 then let’s just use an existing code base. Steal (with Attribution) as much as possible! It’s not worth re-inventing the wheel, especially when it’s inevitably going to be a shitty wheel</li>\n</ul>","frontmatter":{"title":"","date":null,"description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/plan/","previous":{"fields":{"slug":"/ibl/"},"frontmatter":{"title":"Image Based Lighting with Multiple Scattering"}},"next":{"fields":{"slug":"/plan_v2/"},"frontmatter":{"title":""}}}}}